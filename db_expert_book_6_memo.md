## 物理設計
- 物理設計で取り上げられている要素は以下の二つ
  - インデックス
  - 統計情報

#### インデックスとは？
インデックスとはプログラミング的な表現をすると (x, a)という形式でデータが保持される配列
x はキー値、a は実データやポインタが保持される

### インデックスがパフォーマンスを上げる有効な手段となる理由
- アプリケーション、データ透過性
- 性能改善の効果が高い

インデックスを貼ってもアプリケーションコードやテーブルのデータ構造に影響を及ぼさない。そのためインデックスを利用するハードルが低い。(影響を及ぼさないことを「透過性」と言う。)
また、データ量が増えていけばインデックスの性能も劣化するが、その劣化のスピードはデータ量増加に対して緩やかなものとなっている。
透過性が高いにも関わらず、性能改善の効果が高いため、インデックスはDBのパフォーマンスを上げるために有効な手段となり得る

#### B-tree インデックスとは？
インデックスは複数の種類があるが、とりあえず抑えるインデックスは B-tree である。
B-tree とはその名の通り、木構造でデータを保持する。B-tree が平衡木の構造でデータを格納しているため、どのデータを取り出そうとしても同じスピードで取り出すことができる均一性がある。
* 平衡木の説明は[こちら](https://the-simple.jp/what-is-a-balanced-tree-a-title-that-explains-the-basic-concept-of-data-structures-in-an-easy-to-understand-manner)
またB-tree インデックスはテーブルのデータが増加しても性能劣化が緩やかなため、データ量が増加しても検索、更新にかかる計算スピードが変わらない。インデックスを利用しないフルスキャンの場合はデータ量の増加に比例して検索、更新にかかる時間は大きくなる。

TODO: 新ソート性を高めたい
また、DBにおいて COUNT,SUMなどの集計関数 や ORDER BY などのソートはコストが高い演算なのだが、 B-tree インデックスが書かれた列にソートをかけたときにソートの処理がスキップされる。
ちなみに MySQLの場合、 ORDER BY にインデックスが貼られている列を指定してもソート処理がスキップされない。これは MySQL の ORDER BY はインデックスを利用しないからである。(ほんとか？)

### B-tree インデックスを利用するべきポイント
- データ量が多い
データ量が少ない場合はインデックスを貼った時の速度と、フルスキャンによる検索の速度はそんなに変わらない場合がある。（フルスキャンとはテーブル全てのレコードを検索する方法）
データ量が少ないという場合の目安はレコードが10,000行以下の場合。

- カーディナリティが高い
カーディナリティはインデックスを貼るかどうかの最も大切な判断材料になる。カーディナリティとは特定のカラムがどのくらいの種類を持つかを表す概念である。
例えば「性別」を格納する場合には「男性」、「女性」、「選択しない」の３種類しか基本的に格納しないためカーディナリティは低いと言える。
しかし「メールアドレス」は、作成されるパターンが何万もの組み合わせがあり、基本的に一意な情報しか格納されないため、カーディナリティが高いと言える。
基本的にカーディナリティが高いカラムにインデックスを貼ることが好ましいとされる。

カーディナリティが高い目安は「その列をキーに絞り込みを行った結果、全体の5％程度に絞れるかどうかが一つの基準になる」と述べられている。
例えば「性別」カラムの場合、入る値が３種類に限定されるので（大枠は２種類）、ほぼ性別が半々に分布されている前提であれば、男性で絞り込んだ場合には全体の40%から50%近くに男性を表すカラムが格納されていることになる。
この割合は5%よりも大きいので、カーディナリティが低いとされる。

- 頻繁に更新されない

### 意味がないインデックスの使い方
  - 演算
  - is_null
  - 否定系


### 統計情報