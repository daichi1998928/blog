## 物理設計
- 物理設計で取り上げられている要素は以下の二つ
  - インデックス
  - 統計情報

#### インデックスとは？
インデックスとはプログラミング的な表現をすると (x, a)という形式でデータが保持される配列
x はキー値、a は実データやポインタが保持される

### インデックスがパフォーマンスを上げる有効な手段となる理由
- アプリケーション、データ透過性
- 性能改善の効果が高い

インデックスを貼ってもアプリケーションコードやテーブルのデータ構造に影響を及ぼさない。そのためインデックスを利用するハードルが低い。(影響を及ぼさないことを「透過性」と言う。)
また、データ量が増えていけばインデックスの性能も劣化するが、その劣化のスピードはデータ量増加に対して緩やかなものとなっている。
透過性が高いにも関わらず、性能改善の効果が高いため、インデックスはDBのパフォーマンスを上げるために有効な手段となり得る

#### B-tree インデックスとは？
インデックスは複数の種類があるが、とりあえず抑えるインデックスは B-tree である。
B-tree とはその名の通り、木構造でデータを保持する。B-tree が平衡木の構造でデータを格納しているため、どのデータを取り出そうとしても同じスピードで取り出すことができる均一性がある。
* 平衡木の説明は[こちら](https://the-simple.jp/what-is-a-balanced-tree-a-title-that-explains-the-basic-concept-of-data-structures-in-an-easy-to-understand-manner)
またB-tree インデックスはテーブルのデータが増加しても性能劣化が緩やかなため、データ量が増加しても検索、更新にかかる計算スピードが変わらない。インデックスを利用しないフルスキャンの場合はデータ量の増加に比例して検索、更新にかかる時間は大きくなる。

TODO: 新ソート性を高めたい
また、DBにおいて COUNT,SUMなどの集計関数 や ORDER BY などのソートはコストが高い演算なのだが、 B-tree インデックスが書かれた列にソートをかけたときにソートの処理がスキップされる。
ちなみに MySQLの場合、 ORDER BY にインデックスが貼られている列を指定してもソート処理がスキップされない。これは MySQL の ORDER BY はインデックスを利用しないからである。(ほんとか？)

### B-tree インデックスを利用するべきポイント
- データ量が多い
データ量が少ない場合はインデックスを貼った時の速度と、フルスキャンによる検索の速度はそんなに変わらない場合がある。（フルスキャンとはテーブル全てのレコードを検索する方法）
データ量が少ないという場合の目安はレコードが10,000行以下の場合。

- カーディナリティが高い
- 頻繁に更新されない

### 意味がないインデックスの使い方
  - 演算
  - is_null
  - 否定系


### 統計情報